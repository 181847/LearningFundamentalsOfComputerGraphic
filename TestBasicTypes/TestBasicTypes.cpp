// For Unit Test
#include <MyTools\UnitTestModules.h>
#include <iostream>
#include <MyTools\RandomToolNeedLib\MTRandom.h>
#include <MyTools\MathTool.h>
#include <limits>
#include <array>
#include <ctime>
#include <iomanip>
#pragma comment(lib, "MyTools\\lib\\MyTool.lib")

#include "../CommonClasses/DebugHelpers.h"

// include test target code
#include "../CommonClasses/vector2.h"
#include "../CommonClasses/vector3.h"
#include "../CommonClasses/Image.h"
#include "../CommonClasses/OrthographicCamera.h"
#include "../CommonClasses/Ray.h"
#include "../CommonClasses/Sphere.h"
#include "../CommonClasses/PerspectiveCamera.h"
#include "../CommonClasses/Triangle.h"
#include "../CommonClasses/Scene.h"
#include "../CommonClasses/Polygon.h"
#include "../CommonClasses/ColorTemplate.h"
#include "../CommonClasses/Light.h"
#include "../CommonClasses/Material.h"
#include "../CommonClasses/hvector.h"
#include "../CommonClasses/Transform.h"
#include "../CommonClasses/Pipline.h"
#include "../CommonClasses/CoordinateFrame.h"
#include "../CommonClasses/FixPointNumber.h"
#include "../CommonClasses/EFloat.h"
#include "../CommonClasses/DebugConfigs.h"
#pragma comment(lib, "CommonClasses.lib")

using namespace CommonClass;


RandomTool::MTRandom globalMtr;
const unsigned int G_MAX_INT = 1000;



/*!
    \brief this function is for floating point number round error analysist.
*/
template<typename RESULT_T, typename LONG_RESULT_T, typename BOUND_T>
void ShowNumberInBound(const RESULT_T value, const RESULT_T errorBound, const LONG_RESULT_T preciseValue, const BOUND_T low, const BOUND_T high)
{
    std::cout
        << std::setprecision(std::numeric_limits<LONG_RESULT_T>::digits10 + 1)
        << "||||\nlow resolution number = " << value << std::endl
        << "error bound           = " << errorBound << std::endl
        << "high precise number   = " << preciseValue << std::endl
        << "bounded interval      = [ " << low << " , " << high << " ]" << std::endl
        << "||||\n" << std::endl;
}

/*!
    \brief some common configurations for the test.
*/
namespace UserConfig
{
    /*!
    \brief whether let user check some output image file is right,
    if false every check about the Image will be default to be correct.
    */
    const bool LET_USER_CHECK_IMG = false;

    /*!
    \brief common image resolution on width
    */
    const Types::U32 COMMON_PIXEL_WIDTH = 512;

    /*!
    \brief common image resolution on height
    */
    const Types::U32 COMMON_PIXEL_HEIGHT = 512;

    /*!
    \brief common render option, left bound location
    */
    const Types::F32 COMMON_RENDER_LEFT = -3.0f;


    /*!
    \brief common render option, right bound location
    */
    const Types::F32 COMMON_RENDER_RIGHT = +3.0f;


    /*!
    \brief common render option, bottom bound location
    */
    const Types::F32 COMMON_RENDER_BOTTOM = -3.0f;


    /*!
    \brief common render option, right bound location
    */
    const Types::F32 COMMON_RENDER_TOP = +3.0f;

}

/*!
    \brief get random vector3.
    if you want to set the seed, try globalMtr.SetRandomSeed(...);
*/
CommonClass::vector3 GetRandomVector3(bool allowZeroVector = true)
{
    CommonClass::vector3 randVec;
    do
    {
        randVec = CommonClass::vector3((globalMtr.Random() - 0.5f) * (globalMtr.Random(G_MAX_INT) + 1),
            (globalMtr.Random() - 0.5f) * (globalMtr.Random(G_MAX_INT) + 1),
            (globalMtr.Random() - 0.5f) * (globalMtr.Random(G_MAX_INT) + 1));

        // if allowZeroVector is false, loop until a none zero vector
    } while (!allowZeroVector && randVec.m_x == 0.0f && randVec.m_y == 0.0f && randVec.m_z == 0.0f);


    return randVec;
}

/*!
    \brief get random RGB color
    the random number is generated by the globalMtr (which is also used by other functions in this test module).
*/
RGB GetRandomRGB()
{
    return RGB(globalMtr.Random(), globalMtr.Random(), globalMtr.Random());
}

/*!
    \brief this struct is for unit test of DebugClient.
*/
struct TestDebugConf
{
    static bool Active;
    enum { ENABLE_CLIENT = 1};
};
bool TestDebugConf::Active = false;

/*!
    \brief let user to check the local image file, this function can be disabled by the constant UserConfig::LET_USER_CHECK_IMG.
    if the user input some number, then we think this test is passed, and return 0 for no error.
*/
unsigned int LetUserCheckJudge(const std::string& msg, bool force = UserConfig::LET_USER_CHECK_IMG)
{
    if (force)
    {
        std::cout << "Please check: " << msg << std::endl
            << "Input '0' ~ '9' for test pass." << std::endl
            << "Else hit enter for some error: ";

        char ch = std::cin.get();

        // if the character is not number, then the image is wrong.
        if (ch < '0' || ch > '9')
        {
            return 1;
        }

        std::cin.clear();
        std::cin.ignore(std::numeric_limits<int>::max(), '\n');
    }

    // no error happend 
    return 0;
}

TEST_MODULE_START

#pragma region Try the testUnit
	TEST_UNIT_START("a test always success")
	TEST_UNIT_END;
#pragma endregion

#pragma region test vector2
	TEST_UNIT_START("test vector2")
		CommonClass::vector2 v2;
        
        errorLogger.LogIfNotEq(v2.m_x, 0.0f);
        errorLogger.LogIfNotEq(v2.m_y, 0.0f);
	TEST_UNIT_END;
#pragma endregion

#pragma region test vector2 +/ -/ *
	TEST_UNIT_START("test vector2 +/ -/ *")

		RandomTool::MTRandom mtr;
		const unsigned int MAX_RAND_INT = 600;
		
		for (int i = 0; i < 200; ++i)
		{
			const Types::F32	comf1(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)), 
								comf2(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
								comf3(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
								comf4(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1));
			CommonClass::vector2 cmp1(comf1, comf2);
			CommonClass::vector2 cmp2(comf3, comf4);

			// cmp1 + cmp2
			errorLogger.LogIfNotEq(
				cmp1 + cmp2,
				CommonClass::vector2(comf1 + comf3, comf2 + comf4));

			// cmp1 - cmp2
			errorLogger.LogIfNotEq(
				cmp1 - cmp2,
				CommonClass::vector2(comf1 - comf3, comf2 - comf4));

			// cmp1 * cmp2
			errorLogger.LogIfNotEq(
				cmp1 * cmp2,
				(comf1 * comf3 + comf2 * comf4));

			// cmp1 * cmp2
			errorLogger.LogIfNotEq(
				CommonClass::dotProd(cmp1, cmp2),
				(comf1 * comf3 + comf2 * comf4));
		}
	TEST_UNIT_END;
#pragma endregion

#pragma region test vector3 +/ -/ *
	TEST_UNIT_START("test vector3 +/ -/ */ X")
		using namespace CommonClass;
		RandomTool::MTRandom mtr;
		const unsigned int MAX_RAND_INT = 600;
		
		for (int i = 0; i < 200; ++i)
		{
			const Types::F32	comf1(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)), 
								comf2(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
								comf3(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
								comf4(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
								comf5(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
								comf6(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1));
			CommonClass::vector3 cmp1(comf1, comf2, comf3);
			CommonClass::vector3 cmp2(comf4, comf5, comf6);

			// cmp1 + cmp2
			errorLogger.LogIfNotEq(
				cmp1 + cmp2,
				CommonClass::vector3(comf1 + comf4, comf2 + comf5, comf3 + comf6));

			// cmp1 - cmp2
			errorLogger.LogIfNotEq(
				cmp1 - cmp2,
				CommonClass::vector3(comf1 - comf4, comf2 - comf5, comf3 - comf6));
			
			// cmp1 * cmp2
			errorLogger.LogIfNotEq(
				cmp1 * cmp2,
				(comf1 * comf4 + comf2 * comf5 + comf3 * comf6));

			// cmp1 * cmp2
			errorLogger.LogIfNotEq(
				CommonClass::dotProd(cmp1, cmp2),
				(comf1 * comf4 + comf2 * comf5 + comf3 * comf6));

			// cmp1 X cmp2
			errorLogger.LogIfNotEq(
				CommonClass::crossProd(cmp1, cmp2),
				CommonClass::vector3(
					comf2 * comf6 - comf5 * comf3,
					comf4 * comf3 - comf1 * comf6,
					comf1 * comf5 - comf4 * comf2));

			// vector3 * float
			Types::F32 randomFloat = mtr.Random();
			errorLogger.LogIfNotEq(
				cmp1 * randomFloat,
				vector3(
					comf1 * randomFloat,
					comf2 * randomFloat,
					comf3 * randomFloat)); 
			errorLogger.LogIfNotEq(
				randomFloat * cmp2,
				vector3(
					comf4 * randomFloat,
					comf5 * randomFloat,
					comf6 * randomFloat));

			// - vector3
			errorLogger.LogIfNotEq(
				-cmp1, 
				vector3(-comf1, -comf2, -comf3));
		}
	TEST_UNIT_END;
#pragma endregion

#pragma region test RGBA +/ -/ rgbMulti/ *(scalar)/ /(scalar)
	TEST_UNIT_START("test RGBA +/ -/ */ *(scalar)/ /(scalar)")
		RandomTool::MTRandom mtr;
		const unsigned int MAX_RAND_INT = 64;

		/*!
			\brief clamp the channel to [0.0f, 1.0f]
		*/
		auto clampChannel = [](Types::F32 ch)-> Types::F32
		{
			if (ch <= 0.0f)
			{
				return 0.0f;
			}
			else if (ch >= 1.0f)
			{
				return 1.0f;
			}
			else
			{
				return ch;
			}
		};

		for (int i = 0; i < 200; ++i)
		{
			/*!
				make up the RGBA channel
			*/
			const Types::F32	comu1(mtr.Random()),
								comu2(mtr.Random()),
								comu3(mtr.Random()),
								comu4(mtr.Random()),
								comu5(mtr.Random()),
								comu6(mtr.Random()),
								comu7(mtr.Random()),
								comu8(mtr.Random());

			/*!
				scale the RGB with float.
			*/
			const Types::F32	comf1(mtr.Random() * mtr.Random(MAX_RAND_INT)),
								comf2(mtr.Random() * mtr.Random(MAX_RAND_INT));

			RGBA cmp1(comu1, comu2, comu3, comu4);
			RGBA cmp2(comu5, comu6, comu7, comu8);

			/*!
				\brief recover the cmp1's value
			*/
			auto recoverCMP1 = [&cmp1, comu1, comu2, comu3, comu4]()
			{
				cmp1 = RGBA(comu1, comu2, comu3, comu4);
			};

			// default constructor can ignore alpha channel, the alpha of the pixel will be set to max(opaque).
			errorLogger.LogIfNotEq(
                RGBA(comu1, comu2, comu3),
                RGBA(comu1, comu2, comu3, RGBA::ALPHA_CHANNEL_OPAQUE));

			// assign
			cmp1 = cmp2;
			errorLogger.LogIfNotEq(
				cmp1,
                RGBA(comu5, comu6, comu7, comu8));
			recoverCMP1();

			// cmp1 + cmp2
			//cmp1 = cmp1 + cmp2;
			errorLogger.LogIfNotEq( 
				cmp1 + cmp2,
                RGBA(clampChannel(comu1 + comu5), clampChannel(comu2 + comu6), clampChannel(comu3 + comu7), clampChannel(comu4 + comu8)));
			//recoverCMP1();

			// cmp1 - cmp2
            //cmp1 = cmp1 - cmp2;
			errorLogger.LogIfNotEq(
				cmp1 - cmp2,
                RGBA(clampChannel(comu1 - comu5), clampChannel(comu2 - comu6), clampChannel(comu3 - comu7), clampChannel(comu4 - comu8)));
			//recoverCMP1();
			
			// cmp1 * cmp2
			//cmp1 = cmp1 * cmp2,
			errorLogger.LogIfNotEq(
				cmp1 * cmp2,
				RGBA(clampChannel(comu1 * comu5), clampChannel(comu2 * comu6), clampChannel(comu3 * comu7), clampChannel(comu4 * comu8)));
			//recoverCMP1();

			// cmp1 * scalar
			//cmp1.MulRGB(comf1),
			errorLogger.LogIfNotEq(
				cmp1 * comf1,
                RGBA(clampChannel(comu1 * comf1), clampChannel(comu2 * comf1), clampChannel(comu3 * comf1), clampChannel(comu4 * comf1)));
			errorLogger.LogIfNotEq(
			    comf1 * cmp1,       // switch RGBA and scalar
				RGBA(clampChannel(comu1 * comf1), clampChannel(comu2 * comf1), clampChannel(comu3 * comf1), clampChannel(comu4 * comf1)));
			//recoverCMP1();

			// cmp1 / scalar
			//Types::F32 reciprocalComf2 = 1.0f / comf2;
			//cmp1.DivRGB(comf2),
			errorLogger.LogIfNotEq(
				cmp1 / comf2,
				RGBA(clampChannel(comu1 / comf2), clampChannel(comu2 / comf2), clampChannel(comu3 / comf2), clampChannel(comu4 / comf2)));
			//recoverCMP1();
		}
	TEST_UNIT_END;
#pragma endregion

#pragma region test RGB +/ -/ rgbMulti/ *(scalar)/ /(scalar)
	TEST_UNIT_START("test RGB +/ -/ */ *(scalar)/ /(scalar)")
		RandomTool::MTRandom mtr;
		const unsigned int MAX_RAND_INT = 64;

		/*!
			\brief clamp the channel to [0.0f, 1.0f]
		*/
		auto clampChannel = [](Types::F32 ch)-> Types::F32
		{
			if (ch <= 0.0f)
			{
				return 0.0f;
			}
			else if (ch >= 1.0f)
			{
				return 1.0f;
			}
			else
			{
				return ch;
			}
		};

		for (int i = 0; i < 200; ++i)
		{
			/*!
				make up the RGBA channel
			*/
			const Types::F32	comu1(mtr.Random()),
								comu2(mtr.Random()),
								comu3(mtr.Random()),
								comu4(mtr.Random()),
								comu5(mtr.Random()),
								comu6(mtr.Random()),
								comu7(mtr.Random()),
								comu8(mtr.Random());

			/*!
				scale the RGB with float.
			*/
			const Types::F32	comf1(mtr.Random() * mtr.Random(MAX_RAND_INT)),
								comf2(mtr.Random() * mtr.Random(MAX_RAND_INT));

			RGB cmp1(comu1, comu2, comu3);
			RGB cmp2(comu5, comu6, comu7);

			/*!
				\brief recover the cmp1's value
			*/
			auto recoverCMP1 = [&cmp1, comu1, comu2, comu3, comu4]()
			{
				cmp1 = RGB(comu1, comu2, comu3);
			};

			// assign
			cmp1 = cmp2;
			errorLogger.LogIfNotEq(
				cmp1,
                RGB(comu5, comu6, comu7));
			recoverCMP1();

			// cmp1 + cmp2
			//cmp1 = cmp1 + cmp2;
			errorLogger.LogIfNotEq( 
				cmp1 + cmp2,
                RGB(clampChannel(comu1 + comu5), clampChannel(comu2 + comu6), clampChannel(comu3 + comu7)));
			//recoverCMP1();

			// cmp1 - cmp2
            //cmp1 = cmp1 - cmp2;
			errorLogger.LogIfNotEq(
				cmp1 - cmp2,
                RGB(clampChannel(comu1 - comu5), clampChannel(comu2 - comu6), clampChannel(comu3 - comu7)));
			//recoverCMP1();
			
			// cmp1 * cmp2
			//cmp1 = cmp1 * cmp2,
			errorLogger.LogIfNotEq(
				cmp1 * cmp2,
				RGB(clampChannel(comu1 * comu5), clampChannel(comu2 * comu6), clampChannel(comu3 * comu7)));
			//recoverCMP1();

			// cmp1 * scalar
			//cmp1.MulRGB(comf1),
			errorLogger.LogIfNotEq(
				cmp1 * comf1,
                RGB(clampChannel(comu1 * comf1), clampChannel(comu2 * comf1), clampChannel(comu3 * comf1)));
			errorLogger.LogIfNotEq(
			    comf1 * cmp1,       // switch RGBA and scalar
				RGB(clampChannel(comu1 * comf1), clampChannel(comu2 * comf1), clampChannel(comu3 * comf1)));
			//recoverCMP1();

			// cmp1 / scalar
			//Types::F32 reciprocalComf2 = 1.0f / comf2;
			//cmp1.DivRGB(comf2),
			errorLogger.LogIfNotEq(
				cmp1 / comf2,
				RGB(clampChannel(comu1 / comf2), clampChannel(comu2 / comf2), clampChannel(comu3 / comf2)));
			//recoverCMP1();
		}
	TEST_UNIT_END;
#pragma endregion

#pragma region cast between RGBA and RGB
    TEST_UNIT_START("cast between RGBA and RGB")
        RandomTool::MTRandom mtr;
		const unsigned int MAX_RAND_INT = 64;

		/*!
			\brief clamp the channel to [0.0f, 1.0f]
		*/
		auto clampChannel = [](Types::F32 ch)-> Types::F32
		{
			if (ch <= 0.0f)
			{
				return 0.0f;
			}
			else if (ch >= 1.0f)
			{
				return 1.0f;
			}
			else
			{
				return ch;
			}
		};

		for (int i = 0; i < 200; ++i)
		{
			/*!
				make up the RGBA channel
			*/
			const Types::F32	comu1(mtr.Random()),
								comu2(mtr.Random()),
								comu3(mtr.Random()),
								comu4(mtr.Random()),
								comu5(mtr.Random()),
								comu6(mtr.Random()),
								comu7(mtr.Random()),
								comu8(mtr.Random());

			/*!
				scale the RGB with float.
			*/
			const Types::F32	comf1(mtr.Random() * mtr.Random(MAX_RAND_INT)),
								comf2(mtr.Random() * mtr.Random(MAX_RAND_INT));

            RGBA color4(comu1, comu2, comu3, comu4);
            RGB color3(comu5, comu6, comu7);

            errorLogger.LogIfNotEq(Cast(color4), RGB(comu1, comu2, comu3));
            errorLogger.LogIfNotEq(Cast(color3), RGBA(comu5, comu6, comu7, RGBA::ALPHA_CHANNEL_OPAQUE));
            errorLogger.LogIfNotEq(Cast(color3, comu8), RGBA(comu5, comu6, comu7, comu8));
        }
    TEST_UNIT_END;
#pragma endregion

#pragma region check Material construct properties
    TEST_UNIT_START("check Material construct properties")
        using namespace CommonClass;
        const unsigned int MAX_REFLECT_INDEX = 5;
        // reset random seed
        globalMtr.SetRandomSeed(1);

        for (int i = 0; i < 20; ++i)
        {
            RGB color = GetRandomRGB();
            RGB rFresnel0 = GetRandomRGB();
            unsigned int randomReflectIndex = 1 + globalMtr.Random(MAX_REFLECT_INDEX - 1);

            Material mat1;                              // default mat, white color, fresnel coefficient is zero
            Material mat2(color, rFresnel0);            // specific the fresnel coefficient with RGB.
            Material mat3(color, randomReflectIndex);   // calculate fresnel coefficient using reflect index.

            errorLogger.LogIfNotEq(mat1.m_kDiffuse, RGB::WHITE);
            errorLogger.LogIfNotEq(mat1.m_rFresnel_0, RGB::BLACK);

            errorLogger.LogIfNotEq(mat2.m_kDiffuse, color);
            errorLogger.LogIfNotEq(mat2.m_rFresnel_0, rFresnel0);

            // manully calculate the fresnel coefficient.
            Types::F32 reflectIndexToFresnel0 = (randomReflectIndex - 1) * 1.0f / (randomReflectIndex + 1);
            reflectIndexToFresnel0 *= reflectIndexToFresnel0;

            errorLogger.LogIfNotEq(mat3.m_kDiffuse, color);
            errorLogger.LogIfNotEq(mat3.m_rFresnel_0, RGB(reflectIndexToFresnel0, reflectIndexToFresnel0, reflectIndexToFresnel0));

        }
    TEST_UNIT_END;
#pragma endregion

#pragma region vector3 copy constructor
	TEST_UNIT_START("vector3 copy constructor")
		using namespace CommonClass;
		vector3 m3(1.0f, 2.0f, 3.0f);
		vector3 m_toBeError(1.1f, 2.2f, 3.3f);
		vector3 m_copy(m3);

		// construct success
		errorLogger.LogIfFalse(AlmostEqual(m3, m_copy));

		// ensure function AlmostEqual is right
		errorLogger.LogIfTrue(AlmostEqual(m3, m_toBeError));
	TEST_UNIT_END;
#pragma endregion
    
#pragma region vector3 normalize
	TEST_UNIT_START("vector3 normalize")
		using namespace CommonClass;
		using namespace MathTool;
		
		globalMtr.SetRandomSeed(5);

		

		for (int i = 0; i < 20; ++i)
		{
			vector3 v1(GetRandomVector3(false));

			v1 = Normalize(v1);

			errorLogger.LogIfFalse(almost_equal(Length(v1), 1.0f, 8));

			v1.m_x *= 2.0f;
			v1.m_y *= 2.0f;
			v1.m_z *= 3.0f;

			// ensurance, make vector's length not equal to unit.
			errorLogger.LogIfTrue(almost_equal(Length(v1), 1.0f, 8));
		}
	TEST_UNIT_END;
#pragma endregion

#pragma region hvector operation tests
    TEST_UNIT_START("hvector operation tests")
        using namespace CommonClass;
		RandomTool::MTRandom mtr;
		const unsigned int MAX_RAND_INT = 600;
		
        for (int i = 0; i < 200; ++i)
        {
            const Types::F32	comf1(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf2(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf3(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf4(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf5(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf6(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf7(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf8(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf9(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1));


            hvector cmp1(comf1, comf2, comf3, comf4);
            hvector cmp2(comf5, comf6, comf7, comf8);

            // declare some hvector for result comparison
            hvector h_plus_h(comf1 + comf5, comf2 + comf6, comf3 + comf7, comf4),
                    h_minu_h(comf1 - comf5, comf2 - comf6, comf3 - comf7, comf4),
                    h_mult_h(comf1 * comf5, comf2 * comf6, comf3 * comf7, comf4),
                    h_dive_h(comf1 / comf5, comf2 / comf6, comf3 / comf7, comf4),
                    h_mult_s(comf1 * comf9, comf2 * comf9, comf3 * comf9, comf4),
                    s_mult_h(comf1 * comf9, comf2 * comf9, comf3 * comf9, comf4),
                    h_dive_s(comf1 / comf9, comf2 / comf9, comf3 / comf9, comf4);

            TEST_ASSERT((cmp1 + cmp2)   == h_plus_h);

            TEST_ASSERT((cmp1 - cmp2)   == h_minu_h);

            TEST_ASSERT((cmp1 * cmp2)   == h_mult_h);

            TEST_ASSERT((cmp1 / cmp2)   == h_dive_h);

            hvector temp = cmp1;
            temp += cmp2;
            TEST_ASSERT(     temp       == h_plus_h);

            temp = cmp1;
            temp -= cmp2;
            TEST_ASSERT(     temp       == h_minu_h);

            temp = cmp1;
            temp *= cmp2;
            TEST_ASSERT(     temp       == h_mult_h);

            temp = cmp1;
            temp /= cmp2;
            TEST_ASSERT(     temp       == h_dive_h);

            // Next codes is about operations between hvector and scalar
            // hvector * scalar
            TEST_ASSERT( (cmp1 * comf9) == h_mult_s);

            // scalar * hvector
            TEST_ASSERT( (comf9 * cmp1) == s_mult_h);

            // hvector / scalar
            TEST_ASSERT( (cmp1 / comf9) == h_dive_s);

            // hvector *= scalar
            temp = cmp1;
            temp *= comf9;
            TEST_ASSERT(     temp       == h_mult_s);

            // hvector /= scalar
            temp = cmp1;
            temp /= comf9;
            TEST_ASSERT(     temp       == h_dive_s);

            // Next codes ensure that the comparison is not always return true.
            // next comparison will all return false.
            TEST_ASSERT( ! (h_mult_h    == h_dive_h));
            TEST_ASSERT( ! (h_plus_h    == h_minu_h));

        }
    TEST_UNIT_END;
#pragma endregion

#pragma region transform construct tests
    TEST_UNIT_START("transform construct tests")
		RandomTool::MTRandom mtr;
		const unsigned int MAX_RAND_INT = 600;
		
        for (int i = 0; i < 200; ++i)
        {
            TIME_GUARD;
            const Types::F32	comf1(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf2(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf3(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf4(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf5(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf6(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf7(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf8(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf9(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1));

            // Translation 
            Transform trl = Transform::Translation(comf1, comf2, comf3);
            Transform trl_compare(
                1.0f, 0.0f, 0.0f, comf1,
                0.0f, 1.0f, 0.0f, comf2,
                0.0f, 0.0f, 1.0f, comf3,
                0.0f, 0.0f, 0.0f, 1.0f);

            TEST_ASSERT(trl == trl_compare);

            // Rotation transformation
            const Types::F32 cosTheta = std::cosf(comf4),
                             sinTheta = std::sinf(comf4);

            Transform rtx = Transform::RotationX(comf4),
                      rty = Transform::RotationY(comf4),
                      rtz = Transform::RotationZ(comf4);
            
            Transform rtx_compare(
                        1.0f, 0.0f, 0.0f, 0.0f,
                        0.0f, cosTheta, -sinTheta, 0.0f,
                        0.0f, sinTheta, cosTheta, 0.0f,
                        0.0f, 0.0f, 0.0f, 1.0f
                      ),
                      rty_compare(
                          cosTheta, 0.0f, sinTheta, 0.0f,
                          0.0f, 1.0f, 0.0f, 0.0f,
                          -sinTheta, 0.0f, cosTheta, 0.0f,
                          0.0f, 0.0f, 0.0f, 1.0f
                      ),
                      rtz_compare(
                          cosTheta, -sinTheta, 0.0f, 0.0f,
                          sinTheta, cosTheta, 0.0f, 0.0f,
                          0.0f, 0.0f, 1.0f, 0.0f,
                          0.0f, 0.0f, 0.0f, 1.0f
                      );
            
            TEST_ASSERT(rtx == rtx_compare);
            TEST_ASSERT(rty == rty_compare);
            TEST_ASSERT(rtz == rtz_compare);

            TEST_ASSERT(rtx != trl);
            TEST_ASSERT(rty != trl);
            TEST_ASSERT(rtz != trl);
            TEST_ASSERT(rtx != rty);
            TEST_ASSERT(rtz != rty);


            // Viewport transformation
            const Types::U32 
                comu1(mtr.Random(MAX_RAND_INT)),
                comu2(mtr.Random(MAX_RAND_INT)),
                comu3(mtr.Random(MAX_RAND_INT)), 
                comu4(mtr.Random(MAX_RAND_INT));

            // boundries
            const Types::U32 left = comu1, right = comu1 + comu2, bottom = comu3, top = comu3 + comu4;

            Transform viewt = Transform::Viewport(static_cast<Types::F32>(left), static_cast<Types::F32>(right), static_cast<Types::F32>(bottom), static_cast<Types::F32>(top));

            // build nine hvector for view port transformation test.
            std::array<hvector, 9> normalizedPos;
            std::array<Types::F32, 3> constFloats = { -1.0f, 0.0f, 1.0f };
            for (int i = 0; i < 3; ++i)
            {
                for (int j = 0; j < 3; ++j)
                {
                    normalizedPos[i * 3 + j] = hvector(constFloats[i], constFloats[j], 0.0f, 1.0f);
                }
            }

            // build nine hvector which should be the vectors transformed by the Viewport transformation.
            std::array<hvector, 9> screenPos;
            std::array<Types::F32, 3> horizontalPoses = {left - 0.5f, (left + right) * 0.5f , right + 0.5f};
            std::array<Types::F32, 3> verticalPoses   = {bottom - 0.5f, (bottom + top) * 0.5f , top + 0.5f};
            for (int i = 0; i < 3; ++i)
            {
                for (int j = 0; j < 3; ++j)
                {
                    screenPos[i * 3 + j] = hvector(horizontalPoses[i], verticalPoses[j], 0.0f, 1.0f);
                }
            }

            // check whether it is true that "normalizedPos" can be transformed to "screenPos" by "viewt"
            for (int i = 0; i < 9; ++i)
            {
                hvector convertToViewport(viewt * normalizedPos[i]);
                TEST_ASSERT(AlmostEqual(screenPos[i], convertToViewport));
            }
        }
        
    TEST_UNIT_END;
#pragma endregion

#pragma region translate and rotate hvector
    TEST_UNIT_START("translate and rotate hvector")

        
		RandomTool::MTRandom mtr;
		const unsigned int MAX_RAND_INT = 600;
		
        for (int i = 0; i < 200; ++i)
        {
            TIME_GUARD;
            const Types::F32	comf1(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf2(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf3(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf4(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf5(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf6(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf7(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf8(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf9(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1));


            Transform trl = Transform::Translation(comf1, comf2, comf3);    // translation matrix

            hvector vt(comf5, comf6, comf7);    // the vector used to test translation matrix 

            TEST_ASSERT(
                hvector(comf5 + comf1, comf6 + comf2, comf7 + comf3) 
                == (trl * vt));
            
            const Types::F32 pi_div_2 = Types::Constant::PI_F * 0.5f;

            // build rotations about axis of x/y/z
            const Transform
                rotX = Transform::RotationX(pi_div_2),
                rotY = Transform::RotationY(pi_div_2),
                rotZ = Transform::RotationZ(pi_div_2);
            std::array<Transform, 3> rotations = { rotX, rotY, rotZ }; // each one rotate pi/2 about x,y,z


            std::array<hvector, 8> midVs;   // eight vector point at eight quadrants of the space.
            for (unsigned int i = 0; i < midVs.size(); ++i)
            {
                Types::F32 cx, cy, cz;
                
                cx = (i & 4) ? +1.0f : -1.0f;
                cy = (i & 2) ? +1.0f : -1.0f;
                cz = (i & 1) ? +1.0f : -1.0f;

                midVs[i] = hvector(cx, cy, cz, 1.0f);
            }

            
            /*!
                \brief preRotOrder (previous rotation order)
                assist rotation check, used with array "midVs" and "rotations"
                For example:
                preRotOrder[0][0] = 2 means that rotating vector "midVs[0]" with "rotations[0]" will end up with "midVs[2]"
                preRotOrder[2][1] = 3 means that rotating vector "midVs[2]" with "rotations[1]" will end up with "midVs[3]"
            */
            const unsigned preRotOrder[8][3] = {
                { 2, 1, 4 },
                { 0, 5, 5 },
                { 3, 3, 0 },
                { 1, 7, 1 },
                { 6, 0, 6 },
                { 4, 4, 7 },
                { 7, 2, 2 },
                { 5, 6, 3 }
            };

            /*!
                \brief for each vector of "midVs", rotate them with matrixes in "rotations"
            */
            for (unsigned int i = 0; i < midVs.size(); ++i)
            {
                for (unsigned int j = 0; j < rotations.size(); ++j)
                {
                    TEST_ASSERT(AlmostEqual(rotations[j] * midVs[i], midVs[preRotOrder[i][j]], 1e-7f));

                    // ensure the test not always return true;
                    TEST_ASSERT( ! AlmostEqual(rotations[j] * midVs[i] + hvector(0.5f, 0.0f, 0.0f), midVs[preRotOrder[i][j]], 1e-7f));
                }
            }
            
            // old rotations tests, just rotate axis x/y/z and get the results of x -> y -> z -> x...
            hvector axisx(1.0f, 0.0f, 0.0f, 1.0f);
            hvector axisy(0.0f, 1.0f, 0.0f, 1.0f);
            hvector axisz(0.0f, 0.0f, 1.0f, 1.0f);
            hvector axisx_compare = rotY * axisz;
            hvector axisy_compare = rotZ * axisx;
            hvector axisz_compare = rotX * axisy;

            TEST_ASSERT(AlmostEqual(axisx, axisx_compare, 1e-7f));
            TEST_ASSERT(AlmostEqual(axisy, axisy_compare, 1e-7f));
            TEST_ASSERT(AlmostEqual(axisz, axisz_compare, 1e-7f));

            // next few check ensure that test is not always return true.
            TEST_ASSERT( ! AlmostEqual(axisx, axisy_compare, 1e-7f));
            TEST_ASSERT( ! AlmostEqual(axisy, axisz_compare, 1e-7f));
            TEST_ASSERT( ! AlmostEqual(axisz, axisx_compare, 1e-7f));
            
        }
    TEST_UNIT_END;
#pragma endregion

#pragma region test F32Buffer
    TEST_UNIT_START("test F32Buffer")
        RandomTool::MTRandom mtr;
        const unsigned int MAX_RAND_INT = 100;
        const unsigned int SIZE_OF_FLOAT = sizeof(Types::F32);

        std::vector<Types::F32> storeF32s;

        auto checkWithStdVector = [&testParameter, &errorLogger, &storeF32s, &SIZE_OF_FLOAT](std::unique_ptr<F32Buffer> buffer)->void {
            TEST_ASSERT(storeF32s.size() * SIZE_OF_FLOAT == buffer->GetSizeOfByte());
            const unsigned int NUM_CHECKED_FLOATS = buffer->GetSizeOfByte() / SIZE_OF_FLOAT;
            Types::F32 * pBuffer = reinterpret_cast<Types::F32*>(buffer->GetBuffer());


            for (unsigned int i = 0; i < NUM_CHECKED_FLOATS; ++i)
            {
                TEST_ASSERT(storeF32s[i] == pBuffer[i]);
            }
        };

        for (int i = 0; i < 30; ++i)
        {
            const unsigned int NUM_FLOATS = mtr.Random(MAX_RAND_INT);

            storeF32s.resize(NUM_FLOATS);
            auto floatBuffer = std::make_unique<F32Buffer>(NUM_FLOATS * SIZE_OF_FLOAT);

            Types::F32 * pBuffer = reinterpret_cast<Types::F32*>(floatBuffer->GetBuffer());
            for (unsigned int i = 0; i < NUM_FLOATS; ++i)
            {
                Types::F32 comf1(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1));
                pBuffer[i] = comf1;
                storeF32s[i] = comf1;
            }

            checkWithStdVector(std::move(floatBuffer));
        }

    TEST_UNIT_END;
#pragma endregion

#pragma region homogenous space clipping function test
    TEST_UNIT_START("homogenous space clipping function test")
        hvector clippedV0, clippedV1;

        RandomTool::MTRandom mtr;
        const unsigned int SCALE_COMPONENTS_TO = 2;

        /*!
            \brief scale float in [0.0, 1.0] to [-SCALE_COMPONENTS_TO, +SCALE_COMPONENTS_TO]
        */
        auto RemapFloat = [&](const Types::F32 f)->Types::F32 {
            return (f * 2.0f - 1.0f) * SCALE_COMPONENTS_TO;
        };

        /*!
            \brief is the vector's x/y/z in range [-1, +1].
        */
        auto InCube = [](const hvector& v)->bool {
            const Types::F32 epsilon = 1e-5f;
            if ((-1.0f - epsilon) <= v.m_x && v.m_x <= (+1.0f + epsilon)
                && (-1.0f - epsilon) <= v.m_y && v.m_y <= (+1.0f + epsilon)
                && ( -1.0f - epsilon ) <= v.m_z && v.m_z <= ( +1.0f + epsilon))
            {
                return true;
            }
            else
            {
                return false;
            }
        };

        unsigned out = 0, in = 0;
        for (int i = 0; i < 100; ++i)
        {
            std::array<Types::F32, 6> randFloat;
            for (auto & f : randFloat)
            {
                f = RemapFloat(mtr.Random());
            }
            hvector v0(randFloat[0], randFloat[1], randFloat[2], 1.0f);
            hvector v1(randFloat[3], randFloat[4], randFloat[5], 1.0f);

            //PUT_BREAK_POINT;
            bool canDrawThisLine = Pipline::ClipLineInHomogenousClipSpace(
                reinterpret_cast<ScreenSpaceVertexTemplate*>(&v0),
                reinterpret_cast<ScreenSpaceVertexTemplate*>(&v1),
                reinterpret_cast<ScreenSpaceVertexTemplate*>(&clippedV0),
                reinterpret_cast<ScreenSpaceVertexTemplate*>(&clippedV1),
                16);

            if (canDrawThisLine)
            {
                // clipped point must be inside the visible area
                TEST_ASSERT(InCube(clippedV0) && InCube(clippedV1));
                ++in;
            }
            else
            {
                // one of the point must be outside the visible area.
                TEST_ASSERT( (!InCube(v0)) || (!InCube(v1)));
                ++out;
            }// end else
        }// end for

        testConfig.m_testName += " out: " + std::to_string(out) + ", in: " + std::to_string(in);
    TEST_UNIT_END;
#pragma endregion

#pragma region coordinate frame construct
    TEST_UNIT_START("coordinate frame construct")
        
		/*!
			\brief using cross product check two vectors is almost perpendicular to each other.
			Warning: the result of cross product by have a huge differ from 0.0f,
					so the almost_equal will not work properly,
					here we just specify a range (-1e-7f, 1e-7f).
		*/
		auto almostPerpendicular = [](const vector3& a, const vector3& b)->bool
		{
			Types::F32 dpValue = dotProd(a, b);
			//std::printf("## check perpendicular vector3 %f.\n", dpValue);

			return (-1e-6f) < dpValue && dpValue < (1e-6f);
		};

        RandomTool::MTRandom mtr;

        const unsigned int SCALE_FLOAT = 2;

        std::array<Types::F32, 9> rfarr;

        for (int i = 0; i < 20; ++i)
        {
            for (auto & randFloat : rfarr)
            {
                randFloat = SCALE_FLOAT * (mtr.Random() * 2.0f - 1.0f);
            }

            vector3 tu(rfarr[0], rfarr[1], rfarr[2]);
            vector3 tv(rfarr[3], rfarr[4], rfarr[5]);
            vector3 te(rfarr[6], rfarr[7], rfarr[8]);

            CoordinateFrame tcf(tu, tv, te);

            TEST_ASSERT(AlmostPerpendicular(tcf.m_u, tcf.m_v, 1e-6f));
            TEST_ASSERT(AlmostPerpendicular(tcf.m_u, tcf.m_w, 1e-6f));
            TEST_ASSERT(AlmostPerpendicular(tcf.m_v, tcf.m_w, 1e-6f));

            TEST_ASSERT(tcf.m_e == te);
        }
        
    TEST_UNIT_END;
#pragma endregion

#pragma region orthographic transformation test
    TEST_UNIT_START("orthographic transformation test")
        RandomTool::MTRandom mtr;
        const unsigned int MAX_INT = 1080;

        for (int loopCount = 0; loopCount < 20; ++loopCount)
        {

            // six plane parameterss
            const Types::F32 
                LEFT    (-(mtr.Random() - 0.1f) * MAX_INT),
                RIGHT   ( (mtr.Random() + 0.1f) * MAX_INT),
                BOTTOM  (-(mtr.Random() - 0.1f) * MAX_INT),
                TOP     ( (mtr.Random() + 0.1f) * MAX_INT),
                NEAR    ((-mtr.Random() - 0.1f) * MAX_INT),
                FAR     ( NEAR - (mtr.Random() + 0.1f) * MAX_INT); // far plane is more negative than near plane

            // the tested transformation matrix
            Transform orthTransformation = Transform::OrthographicTransOG(LEFT, RIGHT, BOTTOM, TOP, NEAR, FAR);

            // the array help to build hvectors before transformation
            std::array<Types::F32, 3> 
                X_VALUES = {LEFT,   0.5f * (LEFT + RIGHT), RIGHT}, 
                Y_VALUES = {BOTTOM, 0.5f * (BOTTOM + TOP), TOP},
                Z_VALUES = {NEAR,   0.5f * (NEAR + FAR),   FAR };

            // the array help to test hvectors after transformation
            std::array<Types::F32, 3>
                X_NDC = { -1.0f, 0.0f, +1.0f },
                Y_NDC = { -1.0f, 0.0f, +1.0f },
                Z_NDC = { +1.0f, 0.0f, -1.0f };// notice: Z_NDC, +1.0f is for near plane, negative is for far plane

            std::array<hvector, 27> testHvectors;   // the vectors to be transformed
            std::array<hvector, 27> expectedVec;    // the expected result of the transformation result
        
            for (unsigned int i = 0; i < testHvectors.size(); ++i)
            {
                const unsigned int 
                    indexX = i % 3,
                    indexY = (i / 3) % 3,
                    indexZ = (i / 9) % 3;

                testHvectors[i] = hvector(X_VALUES[indexX], Y_VALUES[indexY], Z_VALUES[indexZ]);
                expectedVec[i]  = hvector(X_NDC[indexX],    Y_NDC[indexY],    Z_NDC[indexZ]);
            }// end for build hvectors

            for (unsigned int i = 0; i < testHvectors.size(); ++i)
            {
                hvector transResult(orthTransformation * testHvectors[i]);
                TEST_ASSERT(AlmostEqual(transResult, expectedVec[i], 1e-6f));

                // transform another hvector, but check with the same expectedVec[i]
                // CREATE AN ERROR
                hvector mustFailResult(orthTransformation * testHvectors[(i + 4) % testHvectors.size()]);

                // ensure the result is not always success
                TEST_ASSERT( ! AlmostEqual(mustFailResult, expectedVec[i], 1e-6f));
            }// end for testHvectors

        }// end for loopCount

    TEST_UNIT_END;
#pragma endregion

#pragma region transformation matrix concation
    TEST_UNIT_START("transformation matrix concation")

        // the combination of two transformation
        // for simplicity, just to multiply a transfrom with a unit matrix
        // and ensure the result is still right.
        
        
		RandomTool::MTRandom mtr;
		const unsigned int MAX_RAND_INT = 600;

        // the transform is default to be a unit matrix.
        const Transform UNIT_MATRIX;
		
        for (int i = 0; i < 200; ++i)
        {
            TIME_GUARD;
            const Types::F32	comf1(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf2(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf3(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf4(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf5(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf6(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf7(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf8(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1)),
                                comf9(1.0f * mtr.Random(MAX_RAND_INT) / (mtr.Random(MAX_RAND_INT) + 1));


            // NOTICE, when build those matrix, multiply them by the unit matrix.
            Transform trl = UNIT_MATRIX * Transform::Translation(comf1, comf2, comf3);    // translation matrix

            hvector vt(comf5, comf6, comf7);    // the vector used to test translation matrix 

            TEST_ASSERT(
                hvector(comf5 + comf1, comf6 + comf2, comf7 + comf3) 
                == (trl * vt));
            
            const Types::F32 pi_div_2 = Types::Constant::PI_F * 0.5f;

            // build rotations about axis of x/y/z

            // NOTICE, when build those matrix, multiply them by the unit matrix.
            const Transform
                rotX = UNIT_MATRIX * Transform::RotationX(pi_div_2),
                rotY = UNIT_MATRIX * Transform::RotationY(pi_div_2),
                rotZ = UNIT_MATRIX * Transform::RotationZ(pi_div_2);
            std::array<Transform, 3> rotations = { rotX, rotY, rotZ }; // each one rotate pi/2 about x,y,z


            std::array<hvector, 8> midVs;   // eight vector point at eight quadrants of the space.
            for (unsigned int i = 0; i < midVs.size(); ++i)
            {
                Types::F32 cx, cy, cz;
                
                cx = (i & 4) ? +1.0f : -1.0f;
                cy = (i & 2) ? +1.0f : -1.0f;
                cz = (i & 1) ? +1.0f : -1.0f;

                midVs[i] = hvector(cx, cy, cz, 1.0f);
            }

            
            /*!
                \brief preRotOrder (previous rotation order)
                assist rotation check, used with array "midVs" and "rotations"
                For example:
                preRotOrder[0][0] = 2 means that rotating vector "midVs[0]" with "rotations[0]" will end up with "midVs[2]"
                preRotOrder[2][1] = 3 means that rotating vector "midVs[2]" with "rotations[1]" will end up with "midVs[3]"
            */
            const unsigned preRotOrder[8][3] = {
                { 2, 1, 4 },
                { 0, 5, 5 },
                { 3, 3, 0 },
                { 1, 7, 1 },
                { 6, 0, 6 },
                { 4, 4, 7 },
                { 7, 2, 2 },
                { 5, 6, 3 }
            };

            /*!
                \brief for each vector of "midVs", rotate them with matrixes in "rotations"
            */
            for (unsigned int i = 0; i < midVs.size(); ++i)
            {
                for (unsigned int j = 0; j < rotations.size(); ++j)
                {
                    TEST_ASSERT(AlmostEqual(rotations[j] * midVs[i], midVs[preRotOrder[i][j]], 1e-7f));

                    // ensure the test not always return true;
                    TEST_ASSERT( ! AlmostEqual(rotations[j] * midVs[i] + hvector(0.5f, 0.0f, 0.0f), midVs[preRotOrder[i][j]], 1e-7f));
                }
            }
            
            // old rotations tests, just rotate axis x/y/z and get the results of x -> y -> z -> x...
            hvector axisx(1.0f, 0.0f, 0.0f, 1.0f);
            hvector axisy(0.0f, 1.0f, 0.0f, 1.0f);
            hvector axisz(0.0f, 0.0f, 1.0f, 1.0f);
            hvector axisx_compare = rotY * axisz;
            hvector axisy_compare = rotZ * axisx;
            hvector axisz_compare = rotX * axisy;

            TEST_ASSERT(AlmostEqual(axisx, axisx_compare, 1e-7f));
            TEST_ASSERT(AlmostEqual(axisy, axisy_compare, 1e-7f));
            TEST_ASSERT(AlmostEqual(axisz, axisz_compare, 1e-7f));

            // next few check ensure that test is not always return true.
            TEST_ASSERT( ! AlmostEqual(axisx, axisy_compare, 1e-7f));
            TEST_ASSERT( ! AlmostEqual(axisy, axisz_compare, 1e-7f));
            TEST_ASSERT( ! AlmostEqual(axisz, axisx_compare, 1e-7f));
            
        }
    TEST_UNIT_END;
#pragma endregion

#pragma region Fix Point Number basic test
    TEST_UNIT_START("Fix Point Number basic test")
        testParameter.m_breakIfTestAssertionFailed = true;
        FixPointNumber a(100);
        FixPointNumber b(100.0f);

        TEST_ASSERT(a.ToFloat() == 100.0f);
        TEST_ASSERT(b.ToFloat() == 100.0f);

        RandomTool::MTRandom mtr;
        
        /*!
            \brief return a random float in a large range.
        */
        auto RandFloat = [&mtr]()->Types::F32{
            const int MAX_INT = 180;
            return (mtr.Random() * 2.0f - 1.0f) * MAX_INT;
        };
        
        const unsigned int NUM_FLOAT_PAIRS = 16;
        std::array<Types::F32, NUM_FLOAT_PAIRS> farr1;
        std::array<Types::F32, NUM_FLOAT_PAIRS> farr2;
        std::array<FixPointNumber, NUM_FLOAT_PAIRS> fparr1;
        std::array<FixPointNumber, NUM_FLOAT_PAIRS> fparr2;
        for (int i = 0; i < NUM_FLOAT_PAIRS; ++i)
        {
            farr1[i] = RandFloat();
            farr2[i] = RandFloat();
            
            fparr1[i] = FixPointNumber(farr1[i]);
            fparr2[i] = FixPointNumber(farr2[i]);
        }

        for (int i = 0; i < NUM_FLOAT_PAIRS; ++i)
        {
            const Types::F32 correctResult = farr1[i] * farr2[i];
            const Types::F32 testResult = (fparr1[i] * fparr2[i]).ToFloat();
            TEST_ASSERT(MathTool::AlmostEqual(correctResult, testResult, 0.01f));
        }

        // the fixed point number is not completed, so this test will always failed, 
        // until you fix all the bugs.
        errorLogger++;

    TEST_UNIT_END;
#pragma endregion

#pragma region float bound find
TEST_UNIT_START("float bound find")
    RandomTool::MTRandom mtr;

    const unsigned int MAX_INT = 100;
    
    for (int loopTest = 0; loopTest < 20; ++loopTest)
    {

        float a = mtr.Random() * MAX_INT;
        float b = mtr.Random() * MAX_INT;
        long double la = a, lb = b;

        const int sizeofDouble = sizeof(long double);

        float c = a * b;
        long double lc = la * lb;
    
        float errorBound = std::abs(c) * gamma(1);

        float low = c - errorBound, high = c + errorBound;

        // ensure the bound include the more precise value which is processed by production of double.
        TEST_ASSERT(low <= lc && lc <= high);

        //ShowNumberInBound(c, errorBound, lc, low, high);

        // next codes will check whether the error bound caculateion still apply to sqrt operation
        double lSqrtC = std::sqrt(lc);

        float sqrtC = std::sqrt(c);

        float sqrtErrorBound = std::abs(sqrtC) * gamma(2);

        float sqrtLow = sqrtC - sqrtErrorBound, sqrtHigh = sqrtC + sqrtErrorBound;

        TEST_ASSERT( sqrtLow <= lSqrtC && lSqrtC <= sqrtHigh );

        //ShowNumberInBound(sqrtC, sqrtErrorBound, lSqrtC, sqrtLow, sqrtHigh);

    } // end for loopTest

TEST_UNIT_END;
#pragma endregion

#pragma region EFloat tool test
TEST_UNIT_START("EFloat tool test")
    RandomTool::MTRandom mtr;

    const unsigned int MAX_INT = 100;

    const unsigned int MAX_NUM = 50;
    
    for (int numLoop = 0; numLoop < 20; ++numLoop)
    {
        ShowProgress(numLoop * 1.0f / 20);

        // original number array
        std::array<float, MAX_NUM> farr;

        // assign numbers to the Array "farr".
        farr[0] = 0.0f;
        farr[1] = -0.0f;
        farr[2] = mtr.Random();

        const int POSITIVE_INF = 3;
        const int NEGATIVE_INF = 4;
        const int POSITIVE_MAX = 5;
        const int NEGATIVE_MAX = 6;
        farr[POSITIVE_INF] = +std::numeric_limits<float>::infinity();
        farr[NEGATIVE_INF] = -std::numeric_limits<float>::infinity();
        farr[POSITIVE_MAX] = +std::numeric_limits<float>::max();
        farr[NEGATIVE_MAX] = -std::numeric_limits<float>::max();

        for (unsigned int i = NEGATIVE_MAX + 1; i < farr.size(); ++i)
        {
            farr[i] = (mtr.Random() - 0.5f) * 2.0f * MAX_INT;
        }

        // float up
        std::array<float, farr.size()> fuparr;

        // float down
        std::array<float, farr.size()> fdownarr;

        for (int i = 0; i < farr.size(); ++i)
        {
            //BREAK_POINT_IF(i == 4);
            fuparr[i] = NextFloatUp(farr[i]);
            fdownarr[i] = NextFloatDown(farr[i]);
        }

        for (int i = 0; i < farr.size(); ++i)
        {
            if (i == POSITIVE_INF)
            {
                TEST_ASSERT(fdownarr[i] < farr[i]);
                TEST_ASSERT(std::isinf(fuparr[i]));// move +inf up will stay +inf
            }
            else if (i == NEGATIVE_INF)
            {
                TEST_ASSERT(std::isinf(fdownarr[i]));// move -inf down will stay -inf
                TEST_ASSERT(fuparr[i] > farr[i]);
            }
            else if (i == POSITIVE_MAX)
            {
                TEST_ASSERT(fdownarr[i] < farr[i]);
                TEST_ASSERT(std::isinf(fuparr[i]) && fuparr[i] > 0.);// move +max up will end with +inf
            }
            else if (i == NEGATIVE_MAX)
            {
                TEST_ASSERT(std::isinf(fdownarr[i]) && fdownarr[i] < 0.);// move -max down will end with -inf
                TEST_ASSERT(fuparr[i] > farr[i]);
            }
            else // normal test
            {
                TEST_ASSERT(fuparr[i] > farr[i]);
                TEST_ASSERT(fdownarr[i] < farr[i]);
            }// end else normal test

        }// end for test farr.


    }// end for numLoop
    
    
TEST_UNIT_END;
#pragma endregion

#pragma region EFloat construct test
TEST_UNIT_START("EFloat construct")
    RandomTool::MTRandom mtr;
    const int MAX_INT = 300;
    const int MAX_NUM = 7;

    for (int numLoop = 0; numLoop < 20; ++numLoop)
    {
        // original number array
        std::array<float, MAX_NUM> farr;
        std::array<EFloat, farr.size()> efarr;

        // assign numbers to the Array "farr".
        farr[0] = 0.0f;
        farr[1] = -0.0f;
        farr[2] = mtr.Random();
    
        const int POSITIVE_INF = 3;
        const int NEGATIVE_INF = 4;
        const int POSITIVE_MAX = 5;
        const int NEGATIVE_MAX = 6;
        farr[POSITIVE_INF] = +std::numeric_limits<float>::infinity();
        farr[NEGATIVE_INF] = -std::numeric_limits<float>::infinity();
        farr[POSITIVE_MAX] = +std::numeric_limits<float>::max();
        farr[NEGATIVE_MAX] = -std::numeric_limits<float>::max();

        for (unsigned int i = NEGATIVE_MAX + 1; i < farr.size(); ++i)
        {
            farr[i] = (mtr.Random() - 0.5f) * 2.0f * MAX_INT;
            efarr[i] = EFloat(farr[i]);
        }

        for (auto & ef : efarr)
        {
            ef.Check();
        }
    }// end for numLoop

TEST_UNIT_END;
#pragma endregion

#pragma region EFloat operator test
TEST_UNIT_START("EFloat operator test")
    RandomTool::MTRandom mtr;
    const int MAX_INT = 300;
    const int MAX_NUM = 7;

    for (int numLoop = 0; numLoop < 30; ++numLoop)
    {
        // original number array
        std::array<std::array<float, MAX_NUM>, 2> farr;
        std::array<std::array<EFloat, MAX_NUM>, 2> efarr;

        // start efloat construction
        for (int i = 0; i < 2; ++i)
        {
            for (int j = 0; j < MAX_NUM; ++j)
            {
                farr[i][j] = (mtr.Random() - 0.5f) * 2.0f * MAX_INT;
                efarr[i][j] = EFloat(farr[i][j]);
            }
        }// end for farr[i] construction

        for (int i = 0; i < MAX_NUM; ++i)
        {
            EFloat efResult;
            float floatResult;

            // operator +
            efResult = efarr[0][i] + efarr[1][i];
            floatResult = farr[0][i] + farr[1][i];
            TEST_ASSERT(floatResult == static_cast<Types::F32>(efResult));
            std::cout << farr[0][i] << " + " << farr[1][i] << " = \n"
                      << efResult << "\n\n";

            // operator -
            efResult = efarr[0][i] - efarr[1][i];
            floatResult = farr[0][i] - farr[1][i];
            TEST_ASSERT(floatResult == static_cast<Types::F32>(efResult));
            std::cout << farr[0][i] << " - " << farr[1][i] << " = \n"
                << efResult << "\n\n";

            // operator *
            efResult = efarr[0][i] * efarr[1][i];
            floatResult = farr[0][i] * farr[1][i];
            TEST_ASSERT(floatResult == static_cast<Types::F32>(efResult));
            std::cout << farr[0][i] << " * " << farr[1][i] << " = \n"
                << efResult << "\n\n";

            // operator /
            efResult = efarr[0][i] / efarr[1][i];
            floatResult = farr[0][i] / farr[1][i];
            TEST_ASSERT(floatResult == static_cast<Types::F32>(efResult));
            std::cout << farr[0][i] << " / " << farr[1][i] << " = \n"
                << efResult << "\n\n";

            // abs
            // using the EFloat from previous divided result, which will have some error bound.
            const EFloat efWithBound = efResult;
            efResult = abs(efWithBound);
            TEST_ASSERT(efResult.LowerBound() >= 0.0f);
            TEST_ASSERT(efResult.UpperBound() >= 0.0f);
            TEST_ASSERT(static_cast<Types::F32>(efResult) >= 0.0f);
            TEST_ASSERT(std::abs(static_cast<Types::F32>(efWithBound)) == static_cast<Types::F32>(efResult));
            std::cout << "original = " << efWithBound << std::endl
                      << "absolute = " << efResult << std::endl;

            // square root just use the absolute value from the abs(efWithBound)
            const EFloat absWithBound = efResult;
            efResult = sqrt(absWithBound);
            TEST_ASSERT(static_cast<Types::F32>(efResult) == std::sqrt(static_cast<Types::F32>(absWithBound)));
            std::cout << "square root = " << efResult << std::endl;

            // negative
            efResult = -efWithBound;
            TEST_ASSERT( 
                - (static_cast<Types::F32>(efWithBound)) 
                == static_cast<Types::F32>(efResult));
            TEST_ASSERT(
                - efWithBound.LowerBound() 
                == efResult.UpperBound());
            TEST_ASSERT(
                -efWithBound.UpperBound()
                == efResult.LowerBound());
            std::cout << "original = " << efWithBound << std::endl
                      << "negative = " << efResult << std::endl;
        }// end for operation tests

    }// end for numLoop

TEST_UNIT_END;
#pragma endregion

#pragma region DebugClient test
TEST_UNIT_START("DebugClient test")

    TEST_ASSERT(false == DebugClient<TestDebugConf>());

    TestDebugConf::Active = true;

    // you should have encounter a assertion here.
    TEST_ASSERT(true == DebugClient<TestDebugConf>());

    // disable it again,
    TestDebugConf::Active = false;
    TEST_ASSERT(false == DebugClient<TestDebugConf>());

    // using DebugGuard to assist DebugClient
    {
        // inside this scope
        // the TestDebugConf::Active will be set to true
        DebugGuard<TestDebugConf> guard;

        // you should have encounter a assertion here.
        TEST_ASSERT(true == DebugClient<TestDebugConf>());

    }// out side that scop TestDebugConf will be set to false.
    TEST_ASSERT(false == DebugClient<TestDebugConf>());


    // test that the additional condition can control DebugClient
    {
        DebugGuard<TestDebugConf> guard;
        
        // event the TestDebugConf::Active is setted to true,
        // we pass the condition false to disable that.
        TEST_ASSERT(false == DebugClient<TestDebugConf>(false));

        // you should have encounter a assertion here.
        TEST_ASSERT(true  == DebugClient<TestDebugConf>(true));
    }

TEST_UNIT_END;
#pragma endregion

TEST_MODULE_END

