// For Unit Test
#include <MyTools\UnitTestModules.h>
#include <iostream>
#include <MyTools\RandomToolNeedLib\MTRandom.h>
#include <MyTools\MathTool.h>
#include <limits>
#include <array>
#include <ctime>
#pragma comment(lib, "MyTools\\RandomToolNeedLib\\LibForMTRandomAndPrimeSearch.lib")

#include "../CommonClasses/DebugHelpers.h"

// include test target code
#include "../CommonClasses/vector2.h"
#include "../CommonClasses/vector3.h"
#include "../CommonClasses/Image.h"
#include "../CommonClasses/OrthographicCamera.h"
#include "../CommonClasses/Ray.h"
#include "../CommonClasses/Sphere.h"
#include "../CommonClasses/PerspectiveCamera.h"
#include "../CommonClasses/Triangle.h"
#include "../CommonClasses/Scene.h"
#include "../CommonClasses/Polygon.h"
#include "../CommonClasses/ColorTemplate.h"
#include "../CommonClasses/Light.h"
#include "../CommonClasses/Material.h"
#pragma comment(lib, "CommonClasses.lib")

RandomTool::MTRandom globalMtr;
const unsigned int G_MAX_INT = 1000;

/*!
	\brief some common configurations for the test.
*/
namespace UserConfig
{
	/*!
		\brief whether let user check some output image file is right,
		if false every check about the Image will be default to be correct.
	*/
	const bool LET_USER_CHECK_IMG = false;

	/*!
		\brief common image resolution on width
	*/
	const Types::U32 COMMON_PIXEL_WIDTH     = 512;
	
	/*!
		\brief common image resolution on height
	*/
	const Types::U32 COMMON_PIXEL_HEIGHT    = 512;
	
	/*!
		\brief common render option, left bound location
	*/
	const Types::F32 COMMON_RENDER_LEFT     = -3.0f;

	
	/*!
		\brief common render option, right bound location
	*/
	const Types::F32 COMMON_RENDER_RIGHT    = +3.0f;

	
	/*!
		\brief common render option, bottom bound location
	*/
	const Types::F32 COMMON_RENDER_BOTTOM   = -3.0f;

	
	/*!
		\brief common render option, right bound location
	*/
	const Types::F32 COMMON_RENDER_TOP      = +3.0f;

}

/*!
	\brief get random vector3.
	if you want to set the seed, try globalMtr.SetRandomSeed(...);
*/
CommonClass::vector3 GetRandomVector3(bool allowZeroVector = true)
{
	CommonClass::vector3 randVec;
	do
	{
		randVec = CommonClass::vector3((globalMtr.Random() - 0.5f) * (globalMtr.Random(G_MAX_INT) + 1),
			(globalMtr.Random() - 0.5f) * (globalMtr.Random(G_MAX_INT) + 1),
			(globalMtr.Random() - 0.5f) * (globalMtr.Random(G_MAX_INT) + 1));

		// if allowZeroVector is false, loop until a none zero vector
	} while (! allowZeroVector && randVec.m_x == 0.0f && randVec.m_y== 0.0f && randVec.m_z == 0.0f);
	

	return randVec;
}

/*!
    \brief get random RGB color
    the random number is generated by the globalMtr (which is also used by other functions in this test module).
*/
RGB GetRandomRGB()
{
    return RGB(globalMtr.Random(), globalMtr.Random(), globalMtr.Random());
}

/*!
	\brief let user to check the local image file, this function can be disabled by the constant UserConfig::LET_USER_CHECK_IMG.
	if the user input some number, then we think this test is passed, and return 0 for no error.
*/
unsigned int LetUserCheckJudge(const std::string& msg, bool force = UserConfig::LET_USER_CHECK_IMG)
{
	if (force)
	{
		std::cout << "Please check: " << msg << std::endl
			<< "Input '0' ~ '9' for test pass." << std::endl
			<< "Else hit enter for some error: ";

		char ch = std::cin.get();

		// if the character is not number, then the image is wrong.
		if (ch < '0' || ch > '9')
		{
			return 1;
		}

		std::cin.clear();
		std::cin.ignore(std::numeric_limits<int>::max(), '\n');
	}

	// no error happend 
	return 0;
}

TEST_MODULE_START

#pragma region render a scene use scene RayColor() function
	TEST_UNIT_START("render a scene use scene RayColor() function")
		using namespace CommonClass;

		/*!
		`	\brief set scene and light.
		*/
        Scene scene;
        RGB backgroundColor(RGB::BLACK);

        /*!
            \brief make up materials.
        */
        Material sphereMat;
        Material triMat;
        Material polyMat;

        sphereMat.m_kDiffuse        = RGB::RED;
        sphereMat.m_shinness        = 12.0f;
        sphereMat.SetRFresnel0(8);
        triMat.m_kDiffuse           = RGB::YELLOW;
        triMat.m_shinness           = 1.0f;
        triMat.SetRFresnel0(8);
        polyMat.m_kDiffuse          = RGB(0.3f, 0.5f, 0.9f);
        polyMat.m_shinness          = 0.5f;
        polyMat.SetRFresnel0(8);

        vector3 pointLightPosition(-3.0f, 4.0f, 3.0f);
        RGB pointLightColor = RGB::WHITE;
        Light pointLight(pointLightPosition * 5.0f, pointLightColor);

        scene.m_pointLight = pointLight;

		/*!
			\brief set a sphere to render.
		*/
		auto tsph = std::make_unique<Sphere>(vector3(0.0f, 0.0f, 0.0f), 1.0f);
        tsph->m_material = sphereMat;
        auto tsph2 = std::make_unique<Sphere>(vector3(-1.0f, 2.0f, 0.5f), 1.0f);
        tsph2->m_material = sphereMat;
        auto tsph3 = std::make_unique<Sphere>(vector3(-1.0f, 0.0f, 2.0f), 1.0f);
        tsph3->m_material = sphereMat;

        /*!
            \brief render triangles
        */
		const Types::F32 borderLength = 20.0f;
		auto tri1 = std::make_unique<Triangle>(
			vector3(-borderLength, -2.0f, +borderLength),
			vector3(-borderLength, -2.0f, -borderLength),
			vector3(+borderLength, -2.0f, borderLength));
		auto tri2 = std::make_unique<Triangle>(
			vector3(+borderLength, -2.0f, +borderLength),
			vector3(-borderLength, -2.0f, -borderLength),
			vector3(+borderLength, -2.0f, -borderLength));
        tri1->m_material = triMat;
        tri2->m_material = triMat;

        /*!
            \brief render polygon
        */
        auto poly = std::make_unique<Polygon>(
            vector3(-borderLength, -borderLength, -2.0f),
            vector3(-borderLength, borderLength, -2.0f),
            vector3(+borderLength, borderLength, -2.0f)
            );
        poly->AddPoint(vector3(borderLength * 0.9f, -borderLength * 3.0f, -2.0f));
        poly->AddPoint(vector3(borderLength * 0.1f, -borderLength * 4.0f, -2.0f));
        poly->m_material = polyMat;


        scene.Add(std::move(tsph));
        scene.Add(std::move(tsph2));
        scene.Add(std::move(tsph3));
        scene.Add(std::move(tri1));
        scene.Add(std::move(tri2));
        scene.Add(std::move(poly));

		/*!
			\brief config a camera.
		*/
        vector3 camPosition = vector3(1.8f, 1.8f, 1.8f);
        //vector3 camPosition = 2.0f * vector3(1.8f, 1.8f, 1.8f);
        //vector3 camPosition = vector3( -3.8f, 1.0f, 1.8f);
		vector3 camTarget = vector3(0.0f, 0.0f, 0.0f);
		vector3 camLookUp = vector3(0.0f, 1.0f, 0.0f);
		Types::F32 focalLength = 0.5f;
		PerspectiveCamera camera(focalLength, camPosition, camTarget, camLookUp);

		camera.SetFilm(std::make_unique<Film>(
			UserConfig::COMMON_PIXEL_WIDTH, UserConfig::COMMON_PIXEL_HEIGHT,
			-0.5f, +0.5f,
			-0.5f, +0.5f));

		HitRecord hitRec, shadowHitRec;
		Ray viewRay;
		for (unsigned int i = 0; i < camera.m_film->m_width; ++i)
		{
			for (unsigned int j = 0; j < camera.m_film->m_height; ++j)
			{
				viewRay = camera.GetRay(i, j);

                camera.IncomeLight(i, j, scene.RayColor(viewRay, 0.0f, 1000.0f));
			}
		}

		camera.m_film->SaveTo("OutputTestImage\\RenderReflect\\ThisIsForSceneRayColor06.png");

		errorLogger += LetUserCheckJudge(
			"check \".\\OutputTestImage\\RenderReflect\\ThisIsForSceneRayColor01.png\"\n"
			"you should have seen a sphere with some color, the background is dark green.");

	TEST_UNIT_END;
#pragma endregion

TEST_MODULE_END
